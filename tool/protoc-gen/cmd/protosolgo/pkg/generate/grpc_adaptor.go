package generate

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// GRPCAdaptor generates a gRPC service adaptor that bridges the clean interface with gRPC
func GRPCAdaptor(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// generate a new go file for the gRPC adaptor
	g := p.NewGeneratedFile(
		generateFilename(f.Desc.Path(), "_grpc_adaptor"),
		f.GoImportPath,
	)

	// get grpc adaptor service name
	grpcAdaptorName := svc.GoName + "GRPCAdaptor"
	
	// get the gRPC service interface identifier
	grpcServiceInterfaceIdent := f.GoImportPath.Ident(svc.GoName + "Server")

	// add header
	g.P("// Code generated by protoc-gen-passivgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("//")
	g.P("// This auto-generated file is a gRPC service adaptor.")
	g.P("//")
	g.P("// It adapts our Go business logic to the gRPC service definitions.")
	g.P("// The service interface is defined separately for clean architecture,")
	g.P("// and this adaptor connects that interface with gRPC transport.")
	g.P("//")
	g.P("package ", f.GoPackageName)
	g.P()

	// add compile time interface implementation check
	g.P("// Ensure that ", grpcAdaptorName, " implements the ", grpcServiceInterfaceIdent, " interface")
	g.P("var _ ", grpcServiceInterfaceIdent, " = &", grpcAdaptorName, "{}")
	g.P()

	// add methods to make the service provider implement the GRPCService interface
	// --- ServiceProviderName method
	g.P("// ServiceProviderName returns the service provider name")
	g.P("func (a *", grpcAdaptorName, ") ServiceProviderName() string {")
	g.P("\treturn ", svc.GoName, "ServiceProviderName")
	g.P("}")
	g.P()

	// --- RegisterWithGRPCServer method
	g.P("// RegisterWithGRPCServer registers this adaptor with the gRPC server")
	g.P("func (a *", grpcAdaptorName, ") RegisterWithGRPCServer(s ", GRPCPkg.Ident("ServiceRegistrar"), ") {")
	g.P("\t", f.GoImportPath.Ident("Register"), svc.GoName, "Server(s, a)")
	g.P("}")
	g.P()

	// Start the grpc adaptor struct
	g.P("// ", grpcAdaptorName, " exposes an implementation of the ", svc.GoName, " interface over gRPC")
	g.P("type ", grpcAdaptorName, " struct {")

	// add compiled gRPC unimplemented grpc service stub
	g.P("\t", f.GoImportPath.Ident("Unimplemented"+svc.GoName+"Server"))

	// add tracer and service provider
	g.P("\ttracer ", TracingPkg.Ident("Tracer"))
	
	// create field name for the service interface (lowercase first letter)
	serviceFieldName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:]
	g.P("\t", serviceFieldName, " ", svc.GoName, "Interface")

	// end the struct
	g.P("}")
	g.P()

	// write the constructor
	g.P("// New", grpcAdaptorName, " constructs a new ", grpcAdaptorName)
	g.P("func New", grpcAdaptorName, "(")
	g.P("\ttracer ", TracingPkg.Ident("Tracer"), ",")
	g.P("\t", serviceFieldName, " ", svc.GoName, "Interface,")
	g.P(") *", grpcAdaptorName, " {")
	g.P("\treturn &", grpcAdaptorName, "{")
	g.P("\t\ttracer: tracer,")
	g.P("\t\t", serviceFieldName, ": ", serviceFieldName, ",")
	g.P("\t}")
	g.P("}")
	g.P()

	// write the grpc adaptor methods
	for i, method := range svc.Methods {
		// ensure that the GoName of the method has sufficient letters
		if len(method.GoName) == 0 {
			return fmt.Errorf("method GoName should be at least 1 letter long - instead it is blank")
		}

		// start receiver method that adapts a particular service
		g.P("// ", method.GoName, " exposes the ", method.GoName, " method of the ", svc.GoName, " interface over gRPC")
		
		// Check if this is a server streaming method
		if method.Desc.IsStreamingServer() {
			// Generate server streaming method signature (gRPC uses value type, not pointer)
			g.P("func (a *", grpcAdaptorName, ") ", method.GoName, "(request *", method.Input.GoIdent, ", stream ", GRPCPkg.Ident("ServerStreamingServer"), "[", method.Output.GoIdent, "]) error {")
			g.P("\tctx := stream.Context()")
			g.P("\tctx, span := a.tracer.Start(")
			g.P("\t\tctx,")
			g.P("\t\t", svc.GoName, "ServiceProviderName+\"", "GRPCAdaptor.", method.GoName, "\",")
			g.P("\t)")
			g.P("\tdefer span.End()")
			g.P()

			g.P("\t// call the service interface implementation for streaming")
			g.P("\treturn a.", serviceFieldName, ".", method.GoName, "(ctx, request, stream)")
		} else {
			// Generate regular unary method signature (existing behavior)
			g.P("func (a *", grpcAdaptorName, ") ", method.GoName, "(ctx ", ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.P("\tctx, span := a.tracer.Start(")
			g.P("\t\tctx,")
			g.P("\t\t", svc.GoName, "ServiceProviderName+\"", "GRPCAdaptor.", method.GoName, "\",")
			g.P("\t)")
			g.P("\tdefer span.End()")
			g.P()

			g.P("\t// call the service interface implementation")
			responseVarName := strings.ToLower(string(method.GoName[0])) + method.GoName[1:] + "Response"
			g.P("\t", responseVarName, ", err := a.", serviceFieldName, ".", method.GoName, "(ctx, request)")
			g.P("\tif err != nil {")
			g.P("\t\treturn nil, err")
			g.P("\t}")
			g.P()

			g.P("\treturn ", responseVarName, ", nil")
		}
		g.P("}")

		// add space between methods (but not after the last)
		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	return nil
}